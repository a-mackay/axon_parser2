use std::str::FromStr;
use crate::ast::{Arg, Args, Assign, Def, Expr, ExprOrStmt, FnCall, Id, Lambda, Lines, Lit, Param, Stmt, TermBase, TermChain, TermChainItem};

grammar;

pub Assign: Assign = {
    <id:Id> "=" <e:Expr> => Assign::new(id, e),
}

pub Def: Def = {
    <id:Id> ":" Nl? <e:Expr> => Def::new(id, e),
}

pub Do: Lines = {
    "do" Nl? <Lines> "end" => <>,
}

pub Expr: Expr = {
    Do => Expr::Do(<>),
    Id => Expr::Id(<>),
    Lambda => Expr::Lambda(<>),
    Lit => Expr::Lit(<>),
}

pub Lines: Lines = {
    <(<ExprOrStmt> ";"? Nl?)+> => Lines::new(<>),
}

pub Lambda: Lambda = {
    "(" ")" "=>" <ExprOrStmt> => Lambda::new_no_args(Lines::new_from_eos(<>)),
    <id:Id> "=>" <eos:ExprOrStmt> => {
        let param = Param::new(id);
        Lambda::new(vec![param], Lines::new_from_eos(eos))
    },
    "(" <first_param:Param> <params:("," <Param>)*> ")" "=>" <eos:ExprOrStmt> => {
        let mut params = params;
        params.insert(0, first_param);
        Lambda::new(params, Lines::new_from_eos(eos))
    },
}

pub Lit: Lit = {
    "null" => Lit::Null,
    "true" => Lit::Bool(true),
    "false" => Lit::Bool(false),
    Num => Lit::Num(<>),
}

pub Param: Param = {
    <id:Id> ":" <e:Expr> => Param::new_with_default_arg(id, e),
    Id => Param::new(<>),
}

pub Stmt: Stmt = {
    Assign => Stmt::Assign(<>),
    Def => Stmt::Def(<>),
    "return" <Expr> => Stmt::Return(<>),
    "throw" <Expr> => Stmt::Throw(<>),
}

pub TermBase: TermBase = {
    <id:Id> "(" ")" => {
        let fn_call = FnCall::new(id, Args::empty());
        TermBase::FnCall(fn_call)
    },
    <id:Id> "(" <args:Args> ")" => {
        let fn_call = FnCall::new(id, args);
        TermBase::FnCall(fn_call)
    },
    <Id> => TermBase::Var(<>),
    <Lit> => TermBase::Lit(<>),
}

pub TermChain: TermChain = {
    <base:TermBase> <items:(Nl* <TermChainItem>)*> => {
        TermChain::new(base, items)
    },
}

pub TermChainItem: TermChainItem = {
    "." <Id> => TermChainItem::FnCall(FnCall::new(<>, Args::empty())),
    "." <id:Id> " " <lambda:Lambda> => {
        let args = Args::new(vec![Arg::new(Expr::Lambda(lambda))]);
        let fn_call = FnCall::new(id, args);
        TermChainItem::FnCall(fn_call)
    },
    "." <Id> "(" ")" => TermChainItem::FnCall(FnCall::new(<>, Args::empty())),
    "." <id:Id> "(" <args:Args> ")" => TermChainItem::FnCall(FnCall::new(id, args)),
    "." <id:Id> "(" <args:Args> ")" " "+ <lambda:Lambda> => {
        let mut args = args.into_vec();
        args.push(Arg::new(Expr::Lambda(lambda)));
        let fn_call = FnCall::new(id, Args::new(args.into_iter().collect()));
        TermChainItem::FnCall(fn_call)
    },
}

Args: Args = {
    <first_expr:(Nl? <Expr>)> <exprs:("," Nl? <Expr>)*> Nl? => {
        let mut exprs = exprs;
        exprs.insert(0, first_expr);
        Args::new(exprs.into_iter().map(Arg::new).collect())
    }
}

ExprOrStmt: ExprOrStmt = {
    Expr => ExprOrStmt::Expr(<>),
    Stmt => ExprOrStmt::Stmt(<>),
}

Id: Id = {
    r"[a-z]([a-zA-Z0-9_])*" => Id::new(<>),
}

Num: f64 = {
    r"-?\d+(\.\d+)?" => f64::from_str(<>).unwrap(),
}

match {
    r"[[:space:]&&[^\n]]*" => { },
    r"\n" => Nl,
} else {
    _
}